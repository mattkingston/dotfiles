#!/usr/bin/env bash

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# OS Definitions

get_os() {
    declare osName="$(uname -s)"
    declare os=''

    if [ "$osName" == "Darwin" ]; then
        os='osx'
    elif [ "$osName" == "Linux" ] && [ -e "/etc/lsb-release" ]; then
        os='ubuntu'
    else
        os="$osName"
    fi

    printf "%s" "$os"
}

is_supported_version() {
    declare -a v1=(${1//./ })
    declare -a v2=(${2//./ })

    declare i=''

    # Fill empty positions in v1 with zeros
    for (( i=${#v1[@]}; i<${#v2[@]}; i++ )); do
        v1[i]=0
    done

    for (( i=0; i<${#v1[@]}; i++ )); do

        # Fill empty positions in v2 with zeros
        if [[ -z ${v2[i]} ]]; then
            v2[i]=0
        fi

        if (( 10#${v1[i]} < 10#${v2[i]} )); then
            return 1
        fi

    done
}

verify_os() {
    declare -r minOSXVersion='10.9'
    declare -r minUbuntuVersion='12.04'
    declare -r osName="$(uname -s)"

    declare osVersion=''

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    # Check if the OS is `OS X` and
    # it's above the required version

    if [[ "$os" == 'osx' ]]; then
        osVersion="$(sw_vers -productVersion)"

        is_supported_version "$osVersion" "$minOSXVersion" \
            && return 0 \
            || printf "Sorry, this script is intended only for OS X $minOSXVersion+"

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    # Check if the OS is `Ubuntu` and
    # it's above the required version

    elif [[ "$os" == 'ubuntu' ]]; then
        osVersion="$(lsb_release -d | cut -f2 | cut -d' ' -f2)"

        is_supported_version "$osVersion" "$minUbuntuVersion" \
            && return 0 \
            || printf "Sorry, this script is intended only for Ubuntu $minUbuntuVersion+"

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    else
        printf 'Sorry, this script is intended only for OS X and Ubuntu!'
    fi

    return 1
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# OS Dependent Definitions

if [[ -z "$os" ]]; then
    declare os="$(get_os)"
fi

if [[ "$os" == 'osx' ]]; then

    # - - - - - - - - - - -

    # OS X Definitions

    install_package() {
        declare -r CMD="$3"
        declare -r FORMULA="$2"
        declare -r FORMULA_READABLE_NAME="$1"

        if brew "$CMD" list "$FORMULA" &> /dev/null; then
            print_success "$FORMULA_READABLE_NAME"
        else
            execute "brew $CMD install $FORMULA" "$FORMULA_READABLE_NAME"
        fi
    }

    link_package() {
        declare -r CMD="$3"
        declare -r FORMULA="$2"
        declare -r FORMULA_READABLE_NAME="$1"

        if brew list "$FORMULA" &> /dev/null; then
            execute "brew link $FORMULA" "$FORMULA_READABLE_NAME"
        fi
    }

    add_to_source_list() {
        declare -r REPOSITORY="$1"

        brew tap "$REPOSITORY" &> /dev/null
        print_result $? "brew tap $REPOSITORY\n"

        return $?
    }

    package_is_installed() {
        if cmd_exists 'brew'; then
            brew list "$1" \
                && return 0 \
                || return 1;
        fi

        return 1;
    }

    update() {
        # System software update tool
        # https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man8/softwareupdate.8.html

        execute 'sudo softwareupdate --install --all' 'Update system software'

        if cmd_exists 'brew'; then
            execute 'brew update' 'brew (update)'
        fi
    }

    upgrade() {
        if cmd_exists 'brew'; then
            execute 'brew upgrade --all' 'brew (upgrade)'
        fi
    }

    update_and_upgrade() {
        if cmd_exists 'brew'; then
            execute 'brew update' 'brew (update)'
            execute 'brew upgrade --all' 'brew (upgrade)'
        fi
    }

elif [[ "$os" == 'ubuntu' ]]; then

    # - - - - - - - - - - -

    # Ubuntu Definitions

    add_key() {
        wget -qO - "$1" | sudo apt-key add -
        #     │└─ write output to file
        #     └─ don't show output
    }

    accept_key() {
        local keyserver="$1"
        local keys="$2"

        execute_quietly "sudo -E apt-key adv --keyserver $keyserver --recv-keys $keys > /dev/null 2>&1" "Accept keys $2"
    }

    add_all_sources_keys() {
        awk -F/ '/^[[:blank:]]*deb[[:blank:]]+http:\/\/ppa\.launchpad\.net\// {print "https://launchpad.net/~"$4"/+archive"}' \
          /etc/apt/sources.list{,.d/*.list} | \
          xargs -- wget -q -O- | \
          awk -F\" '/http:\/\/keyserver\.ubuntu\.com:11371/ {sub(/amp;op=index/,"op=get");print $2}' | \
          xargs -- wget -q -O- | sudo apt-key add -
    }

    add_ppa() {
        sudo -E add-apt-repository -y ppa:"$1" > /dev/null 2>&1
        print_result $? "${2:-$1}"
    }

    add_to_source_list() {
        sudo sh -c "printf 'deb $1' >> '/etc/apt/sources.list.d/$2'"
        print_result $? "${3:-$2}"
    }

    install_package() {
        declare -r PACKAGE="$2"
        declare -r PACKAGE_READABLE_NAME="$1"

        if ! package_is_installed "$PACKAGE"; then
            print_subtle "Installing: $PACKAGE_READABLE_NAME"

            execute_quietly "sudo -E apt-get -qq install --allow-unauthenticated -y $PACKAGE" "$PACKAGE_READABLE_NAME"
            #        suppress output ─┘                                   │
            #                 assume "yes" as the answer to all prompts ──┘
        else
            print_success "$PACKAGE_READABLE_NAME"
        fi
    }

    package_is_installed() {
        dpkg -s "$1" | grep --only-matching "installed" > /dev/null
    }

    update() {
        print_subtle "Updating: please stand by this could take a while"

        # Resynchronize the package index files from their sources
        execute_quietly 'sudo -E apt-get -qq update -y' 'Update'
    }

    upgrade() {
        print_subtle "Upgrading: please stand by this could take a while"

        # Install the newest versions of all packages installed
        execute_quietly 'sudo -E apt-get -qq upgrade -y' 'Upgrade'
    }

    update_and_upgrade() {
        update
        upgrade
    }

fi

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# System Definitions

ask_for_sudo() {
    # Ask for the administrator password upfront
    sudo -v &> /dev/null

    # Update existing `sudo` time stamp until this script has finished
    # https://gist.github.com/cowboy/3118588
    while true; do
        sudo -n true
        sleep 60
        kill -0 "$$" || exit
    done &> /dev/null &
}

can_sudo() {
    [[ “$(whoami)“ != "root" && ! is_interactive ]] \
        && return 0 \
        || return 1;
}

cmd_exists() {
    command -v "$1" > /dev/null 2>&1
    return $?
}

execute() {
    eval "$1"
    print_result $? "${2:-$1}"
}

execute_quietly() {
    eval "$1" > /dev/null
    print_result $? "${2:-$1}"
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Arguments Definitions

has_argument() { # bool : true (0) | false (1)
    local -r argumentList=$1
    local -r argumentName="$2"

    for i in ${argumentList[@]}; do
        [[ "$i" == "$argumentName" ]] \
            && return 0
    done

    return 1
}

get_prefixed_argument() { # string
    local -r argumentList=$1
    local -r argumentPrefix="$2"

    for i in ${argumentList[@]}; do
        [[ ${argumentList[$i]} =~ ^$argumentPrefix ]] \
            && "$(echo ${argumentList[$i]} | sed s/$argumentPrefix//)"
    done
}

get_next_argument() { # string
    local -r argumentList=$1
    local -r argumentName="$2"
    local -r argumentListLength="${#argumentList}"

    for (( i=0; i < ${argumentListLength}; i++ )); do
        [[ "$i" == "$argumentName" && $i+1 -le "$argumentListLength" ]] \
            && return ${argumentList[$i+1]};
    done
}

get_argument_at() { # string
    local -r argumentList=$1
    local -r argumentIndex="$2"

    [[ -z ${argumentList[$argumentIndex]} ]] \
        && return ${argumentList[$argumentIndex]}
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# File System Definitions

su_mkd() {
    if [[ -n "$1" ]]; then
        if [[ -e "$1" ]]; then
            if [[ ! -d "$1" ]]; then
                print_error "$1 - a file with the same name already exists!"
            else
                print_success "$1"
            fi
        else
            execute "sudo mkdir -p $1" "$1"
        fi
    fi
}

mkd() {
    if [[ -n "$1" ]]; then
        if [[ -e "$1" ]]; then
            if [[ ! -d "$1" ]]; then
                print_error "$1 - a file with the same name already exists!"
            else
                print_success "$1"
            fi
        else
            execute "mkdir -p $1" "$1"
        fi
    fi
}

extract() {
    local archive="$1"
    local output_dir="$2"

    # Extract the contents of a zip file (gzipped donest matter when extracting)
    if command -v 'tar' &> /dev/null; then
        tar -zxf "$archive" --strip-components 1 -C "$output_dir"
        return $?
    fi

    return 1
}

extract_into() {
    local current_dir="$(pwd)"
    local archive="$1"
    local output_dir="$($2 || pwd)"

    # Move into the directory we want to extract into
    cd "$output_dir"

    # Extract the contents of a zip file (gzipped donest matter when extracting)
    if command -v 'tar' &> /dev/null; then
        tar -zxf "$archive" "$archive"
        return $?
    fi

    cd "$current_dir"
}

chown_r() {
    chown -R "$(whoami)":"$(whoami)" $1

    print_success "Changed Owner: $(whoami) $1"
}

truncate() {
    local -r file="$1"

    cat /dev/null > "$file"

    print_success "Truncate: $file"
}

append_to_file() {
    local -r file="$1"
    local -r content="$2"

    printf "$content\n" >> "$file"
    print_success "Append: $file"
}

append_to_file_once() {
    local -r file="$1"
    local -r content="$2"

    if ! pcregrep -qM "$content" "$file"; then
        printf "$content\n" >> "$file"
        print_success "Append: $file"
    fi
}

append_to_file_at_line_once() {
    if [[ "$(get_os)" == 'osx' ]]; then
        echo "Sorry this method will not work in OS X" && return 1
    fi

    local -r file="$1"
    local -r content="$2"
    local -r line="$3"

    if ! pcregrep -qM "$content" "$file"; then
        sed -i "${line}i\n$content\n" "$file"
        print_success "Append: $file:$line"
    fi
}

remove_from_file() {
    if [[ "$(get_os)" == 'osx' ]]; then
        echo "Sorry this method will not work in OS X" && return 1
    fi

    local -r file="$1"
    local -r content="$2"

    if pcregrep -qM "$content" "$file"; then
        sed -i "s/$content//" "$file"

        print_success "Trimmed: $file"
    fi
}

content_in_file() {
    local -r file="$2"
    local -r search="$1"

    pcregrep -qM "$search" "$file" && return 0 || return 1
}

add_source_to_profile() {
    local newInstallDir="$1"
    local bashrcSource="$2"

    if [[ ! -f "$HOME/.profile" ]]; then
        cat > "$HOME/.profile"
        print_success "create $HOME/.profile\n"
    fi

    local content="\n[[ -e $newInstallDir/$bashrcSource ]] \
    && source $newInstallDir/$bashrcSource\n"

    append_to_file_once "$HOME/.profile" "$content"

    return $?
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# String/Numeric handling Definitions

mask_string() {
    local raw="$1"
    echo ${raw:0:1}$( echo "${raw:1: -1}" | tr [:print:] \* )${raw: -1}
}

full_mask_string() {
    local raw="$1"
    echo $raw | tr [:print:] \*
}


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# VCS Definitions

is_git_repository() {
    git rev-parse &> /dev/null
    return $?
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# IO Definitions

is_interactive() {
    [[ -t "0" || ( -t "0" || -p /dev/stdin ) ]] \
        && return 0 \
        || return 1;
}

is_yes() {
    [[ "$1" =~ ^[Yy]es$ || "$1" =~ ^[Yy]$ ]] \
        && return 0 \
        || return 1
}

is_no() {
    [[ "$1" =~ ^[Nn]o?$ ]] \
        && return 0 \
        || return 1
}

ask() {
    print_question "$1"
    read
}

ask_silent() {
    print_question "$1"
    read -s
}

ask_for_confirmation() {
    print_question "$1"

    while read -r -s -n 1; do
        # if the answer is null or “y” or “n” (not case sensitive)
        # we can accept the answer. All other letters are ignored

        if [[ -z "$REPLY" ]] || ([[ -n "$REPLY" ]] && (is_yes "$REPLY" || is_no "$REPLY")); then
            printf "$REPLY"
            break
        fi
    done

    printf "\n"
}

answer_is_null() {
    [[ -z "$REPLY" ]] \
        && return 0 \
        || return 1
}

answer_is_yes() {
    is_yes "$REPLY" \
        && return 0 \
        || return 1
}

get_answer() {
    printf "$REPLY"
}

print_in_green() {
    printf "\e[38;5;82m$1\e[0m"
}

print_in_purple() {
    printf "\e[38;5;165m$1\e[0m"
}

print_in_orange() {
    printf "\e[38;5;136m$1\e[0m"
}

print_in_red() {
    printf "\e[38;5;196m$1\e[0m"
}

print_in_blue() {
    printf "\e[38;5;75m$1\e[0m"
}

print_in_yellow() {
    printf "\e[38;5;226m$1\e[0m"
}

print_in_grey() {
    printf "\e[38;5;240m$1\e[0m"
}

print_in_white() {
    printf "\e[38;5;255m$1\e[0m"
}

print_lf() {
    printf "\n"
}

print_break() {
    printf "\n -----\n\n"
}

print_info() {
    print_in_purple "\n      $1\n"
}

print_subtle() {
    print_in_grey "      $1\n"
}

print_question() {
    print_in_blue "\n  [?] $1 "
}

print_success() {
    print_in_green "\n  [✔] $1\n"
}

print_notice() {
    print_in_yellow "  [!] $1\n"
}

print_error() {
    print_in_red "\n  [✖] $1 $2\n"
}

print_result() {
    [[ "$1" -eq 0 ]] \
        && print_success "$2" \
        || print_error "${3:-$2}";

    return $1
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Proxy Definitions

declare bashLocalProxy="$HOME/.bash.local.proxy"

declare proxyUser=""
declare proxyPass=""

declare proxyDomain=""
declare proxyPort=""
declare proxyUrl=""

declare httpProxyDomain=""
declare httpsProxyDomain=""
declare allProxyDomain=""

declare httpProxyPort=""
declare httpsProxyPort=""
declare allProxyPort=""

declare httpProxyUrl=""
declare httpsProxyUrl=""
declare allProxyUrl=""

declare maskedProxyPass=""

declare proxyUserPass=""

declare maskedProxyUserPass=""

declare maskedHttpProxy=""
declare maskedHttpsProxy=""
declare maskedAllProxy=""

ask_proxy_user() {
    ask 'Please enter your proxy username'
    proxyUser="$(get_answer)"
}

ask_proxy_pass() {
    ask_silent 'Please enter your proxy password'
    proxyPass="$(get_answer)"

    printf "$(full_mask_string $proxyPass)\n"

    set_proxy_pass_masked
    set_proxy_user_and_pass
}

set_proxy_pass_masked() {
    maskedProxyPass="$(mask_string $proxyPass)"
}

set_proxy_user_and_pass() {
    if [ -n "$proxyUser" ]; then
        if [ -n "$proxyPass" ]; then
            proxyUserPass="$proxyUser:$proxyPass@"
            maskedProxyUserPass="$proxyUser:$maskedProxyPass@"
        else
            proxyUserPass="$proxyUser@"
            maskedProxyUserPass="$proxyUser@"
        fi
    fi
}

ask_proxy_domain() {
    ask_for_confirmation "Are there different domains for HTTP and HTTPS proxies?"

    if answer_is_yes; then

        ask 'Please enter the HTTP proxy domain/IP'
        httpProxyDomain="$(get_answer)"

        ask 'Please enter the HTTPS proxy domain/IP'
        httpsProxyDomain="$(get_answer)"

        ask 'Please enter any other proxy domain/IP'
        allProxyDomain="$(get_answer)"

    else

        while [[ -z "$proxyDomain" || "$proxyDomain" == "" ]]; do
            ask 'Please enter the proxy domain/IP'
            proxyDomain="$(get_answer)"
        done

    fi
}

ask_proxy_port() {
    ask_for_confirmation "Are there different ports for HTTP and HTTPS proxies?"

    if answer_is_yes; then

        ask 'Please enter the HTTP proxy port'
        httpProxyPort="$(get_answer)"

        ask 'Please enter the HTTPS proxy port'
        httpsProxyPort="$(get_answer)"

        ask 'Please enter any other proxy port'
        allProxyPort="$(get_answer)"

    else

        ask 'Please enter the proxy port'
        proxyPort="$(get_answer)"

    fi

    set_proxy_url
}

set_proxy_url() {

    # Domain

    if [ -n "$proxyDomain" ]; then
        proxyUrl="$proxyDomain"
    fi

    if [ -n "$httpProxyDomain" ]; then
        httpProxyUrl="$httpProxyDomain"
    fi

    if [ -n "$httpsProxyDomain" ]; then
        httpsProxyUrl="$httpsProxyDomain"
    fi

    if [ -n "$allProxyDomain" ]; then
        allProxyUrl="$allProxyDomain"
    fi

    # Concat port

    if [ -n "$proxyPort" ]; then
        proxyUrl="$proxyUrl:$proxyPort"
    fi

    if [ -n "$httpProxyPort" ]; then
        httpProxyUrl="$httpProxyUrl:$httpProxyPort"
    fi

    if [ -n "$httpsProxyPort" ]; then
        httpsProxyUrl="$httpsProxyUrl:$httpsProxyPort"
    fi

    if [ -n "$allProxyPort" ]; then
        allProxyUrl="$allProxyUrl:$allProxyPort"
    fi

}

concat_proxy_settings() {
    httpProxy="http://${proxyUserPass}${httpProxyUrl:-$proxyUrl}"
    httpsProxy="http://${proxyUserPass}${httpsProxyUrl:-$proxyUrl}"
    allProxy="http://${proxyUserPass}${allProxyUrl:-$proxyUrl}"

    maskedHttpProxy="http://${maskedProxyUserPass}${httpProxyUrl:-$proxyUrl}"
    maskedHttpsProxy="http://${maskedProxyUserPass}${httpsProxyUrl:-$proxyUrl}"
    maskedAllProxy="http://${maskedProxyUserPass}${allProxyUrl:-$proxyUrl}"
}

ask_if_proxy_settings_correct() {
    ask_for_confirmation "Proxy variables are:$(print_in_white "\n\n      HTTP_PROXY=$maskedHttpProxy\n      HTTPS_PROXY=$maskedHttpsProxy\n      ALL_PROXY=$maskedAllProxy")\n\n      $(print_in_blue "Are these correct?")"
}

ask_proxy_settings() {
    ask_proxy_user
    ask_proxy_pass
    ask_proxy_domain
    ask_proxy_port

    concat_proxy_settings

    ask_if_proxy_settings_correct

    if ! answer_is_yes; then
        ask_for_confirmation "Do you want to try setting the proxy settings again?"

        if answer_is_yes; then
            ask_proxy_settings
        fi
    fi
}

save_proxy_settings() {
    if [ -n "$httpProxy" ]; then
        local proxyConfig='
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

        # Proxy

        export PROXY_USER="'$proxyUser'"
        export PROXY_PASS="'$proxyPass'"

        export HTTP_PROXY="'$httpProxy'"
        export HTTPS_PROXY="'$httpsProxy'"
        export ALL_PROXY="'$allProxy'"

        export http_proxy="'$httpProxy'"
        export https_proxy="'$httpsProxy'"
        export all_proxy="'$allProxy'"

        ' # END declare=proxyConfig

        echo "" > "$bashLocalProxy"

        append_to_file_once "$bashLocalProxy" "$proxyConfig"

        print_in_white "\n    Proxy variables have been saved to $bashLocalProxy.\n"

        # TODO - Include this bit in the bash proxy watcher
        if [ "$(get_os)" == 'ubuntu' ]; then
            echo 'Acquire::http::Proxy "'$httpProxy'";' | sudo tee "/etc/apt/apt.conf.d/01proxy" > /dev/null 2>&1
        fi

        print_in_white "\n    Proxy set: /etc/apt/apt.conf.d/01proxy.\n"

        if cmd_exists 'npm'; then
            # TODO - Include this bit in the bash proxy watcher
            execute_quietly "npm config set proxy $HTTP_PROXY" "NPM HTTP Proxy"
            execute_quietly "npm config set https-proxy $HTTPS_PROXY" "NPM HTTPS Proxy"

            print_in_white "\n    Proxy set: $HOME/.npmrc.\n\n"
        fi

        if [[ -n "$RVM_DIRECTORY" && -d "$RVM_DIRECTORY" ]]; then
            # TODO - Include this bit in the bash proxy watcher
            append_to_file_once "$HOME/.gemrc" "http-proxy: $HTTP_PROXY"
            append_to_file_once "$HOME/.gemrc" "https-proxy: $HTTPS_PROXY"

            print_in_white "\n    Proxy set: $HOME/.gemrc.\n"
        fi

        export PROXY_USER="'$proxyUser'"
        export PROXY_PASS="'$proxyPass'"

        export HTTP_PROXY="'$httpProxy'"
        export HTTPS_PROXY="'$httpsProxy'"
        export ALL_PROXY="'$allProxy'"

        export http_proxy="'$httpProxy'"
        export https_proxy="'$httpsProxy'"
        export all_proxy="'$allProxy'"
    fi
}

parse_supplied_proxy() {
    local suppliedProxy="$1"

    if [[ $suppliedProxy =~ ^https?://[^:]+:[^@]+@[^:]+:[0-9]{,4}$ ]]; then
        proxyComplex="$(echo $suppliedProxy | cut -d'/' -f3)"

        proxyUser="$(echo $proxyComplex | cut -d':' -f1)"
        proxyPass="$(echo $proxyComplex | cut -d':' -f2 | cut -d'@' -f1)"

        set_proxy_pass_masked
        set_proxy_user_and_pass

        proxyDomain="$(echo $proxyComplex | cut -d':' -f2 | cut -d'@' -f2)"
        proxyPort="$(echo $proxyComplex | cut -d':' -f3)"

    elif [[ $suppliedProxy =~ ^https?://[^:]+:[0-9]{,4}$ ]]; then
        proxyComplex="$(echo $suppliedProxy | cut -d'/' -f3)"
        proxyDomain="$(echo $proxyComplex | cut -d':' -f1 | cut -d'@' -f2)"
        proxyPort="$(echo $proxyComplex | cut -d':' -f2)"
    fi

    set_proxy_url

    concat_proxy_settings

    if [ "$DEBUG" == "YES" ]; then
        echo '$proxyComplex='$proxyComplex
        echo '$proxyUser='$proxyUser
        echo '$proxyPass='$proxyPass

        echo '$proxyUserPass='$proxyUserPass
        echo '$maskedProxyUserPass='$maskedProxyUserPass

        echo '$proxyDomain='$proxyDomain
        echo '$proxyPort='$proxyPort

        echo '$proxyUrl='$proxyUrl

        echo '$httpProxy='$httpProxy
        echo '$maskedHttpProxy='$maskedHttpProxy
    fi
}

change_proxy() {
    ask_proxy_settings
    save_proxy_settings
}

restart() {
    sudo shutdown -r now &> /dev/null
}